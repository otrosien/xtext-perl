/*
 * generated by Xtext 2.10.0-SNAPSHOT
 */
package org.epic.perl.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class PerlGrammarAccess extends AbstractGrammarElementFinder {
	
	public class PerlModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.epic.perl.Perl.PerlModel");
		private final Assignment cElementsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cElementsAbstractElementParserRuleCall_0 = (RuleCall)cElementsAssignment.eContents().get(0);
		
		//PerlModel:
		//	elements+=AbstractElement*;
		@Override public ParserRule getRule() { return rule; }
		
		//elements+=AbstractElement*
		public Assignment getElementsAssignment() { return cElementsAssignment; }
		
		//AbstractElement
		public RuleCall getElementsAbstractElementParserRuleCall_0() { return cElementsAbstractElementParserRuleCall_0; }
	}
	public class AbstractElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.epic.perl.Perl.AbstractElement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAssignmentParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//AbstractElement:
		//	Assignment | Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//Assignment | Expression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Assignment
		public RuleCall getAssignmentParserRuleCall_0() { return cAssignmentParserRuleCall_0; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_1() { return cExpressionParserRuleCall_1; }
	}
	public class AssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.epic.perl.Perl.Assignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cMyKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cOurKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Keyword cLocalKeyword_0_2 = (Keyword)cAlternatives_0.eContents().get(2);
		private final Assignment cVariableAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVariableIDTerminalRuleCall_1_0 = (RuleCall)cVariableAssignment_1.eContents().get(0);
		private final Assignment cOpAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cOpAlternatives_2_0 = (Alternatives)cOpAssignment_2.eContents().get(0);
		private final RuleCall cOpOpSingleAssignParserRuleCall_2_0_0 = (RuleCall)cOpAlternatives_2_0.eContents().get(0);
		private final RuleCall cOpOpMultiAssignParserRuleCall_2_0_1 = (RuleCall)cOpAlternatives_2_0.eContents().get(1);
		private final Assignment cExpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExpressionExpressionParserRuleCall_3_0 = (RuleCall)cExpressionAssignment_3.eContents().get(0);
		
		//Assignment:
		//	('my' | 'our' | 'local')? variable=ID op=(OpSingleAssign | OpMultiAssign) expression=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//('my' | 'our' | 'local')? variable=ID op=(OpSingleAssign | OpMultiAssign) expression=Expression
		public Group getGroup() { return cGroup; }
		
		//('my' | 'our' | 'local')?
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//'my'
		public Keyword getMyKeyword_0_0() { return cMyKeyword_0_0; }
		
		//'our'
		public Keyword getOurKeyword_0_1() { return cOurKeyword_0_1; }
		
		//'local'
		public Keyword getLocalKeyword_0_2() { return cLocalKeyword_0_2; }
		
		//variable=ID
		public Assignment getVariableAssignment_1() { return cVariableAssignment_1; }
		
		//ID
		public RuleCall getVariableIDTerminalRuleCall_1_0() { return cVariableIDTerminalRuleCall_1_0; }
		
		//op=(OpSingleAssign | OpMultiAssign)
		public Assignment getOpAssignment_2() { return cOpAssignment_2; }
		
		//(OpSingleAssign | OpMultiAssign)
		public Alternatives getOpAlternatives_2_0() { return cOpAlternatives_2_0; }
		
		//OpSingleAssign
		public RuleCall getOpOpSingleAssignParserRuleCall_2_0_0() { return cOpOpSingleAssignParserRuleCall_2_0_0; }
		
		//OpMultiAssign
		public RuleCall getOpOpMultiAssignParserRuleCall_2_0_1() { return cOpOpMultiAssignParserRuleCall_2_0_1; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_3() { return cExpressionAssignment_3; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_3_0() { return cExpressionExpressionParserRuleCall_3_0; }
	}
	public class OpSingleAssignElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.epic.perl.Perl.OpSingleAssign");
		private final Keyword cEqualsSignKeyword = (Keyword)rule.eContents().get(1);
		
		//OpSingleAssign:
		//	'=';
		@Override public ParserRule getRule() { return rule; }
		
		//'='
		public Keyword getEqualsSignKeyword() { return cEqualsSignKeyword; }
	}
	public class OpMultiAssignElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.epic.perl.Perl.OpMultiAssign");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cPlusSignEqualsSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cHyphenMinusEqualsSignKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cAsteriskEqualsSignKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cSolidusEqualsSignKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cPercentSignEqualsSignKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cAsteriskAsteriskEqualsSignKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Group cGroup_6 = (Group)cAlternatives.eContents().get(6);
		private final Keyword cLessThanSignKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Keyword cLessThanSignKeyword_6_1 = (Keyword)cGroup_6.eContents().get(1);
		private final Keyword cEqualsSignKeyword_6_2 = (Keyword)cGroup_6.eContents().get(2);
		private final Group cGroup_7 = (Group)cAlternatives.eContents().get(7);
		private final Keyword cGreaterThanSignKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_7_1 = (Keyword)cGroup_7.eContents().get(1);
		private final Keyword cGreaterThanSignEqualsSignKeyword_7_2 = (Keyword)cGroup_7.eContents().get(2);
		
		//OpMultiAssign:
		//	'+=' | '-=' | '*=' | '/=' | '%=' | '**=' |
		//	'<' '<' '=' |
		//	'>' '>'? '>=';
		@Override public ParserRule getRule() { return rule; }
		
		//'+=' | '-=' | '*=' | '/=' | '%=' | '**=' | '<' '<' '=' | '>' '>'? '>='
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'+='
		public Keyword getPlusSignEqualsSignKeyword_0() { return cPlusSignEqualsSignKeyword_0; }
		
		//'-='
		public Keyword getHyphenMinusEqualsSignKeyword_1() { return cHyphenMinusEqualsSignKeyword_1; }
		
		//'*='
		public Keyword getAsteriskEqualsSignKeyword_2() { return cAsteriskEqualsSignKeyword_2; }
		
		//'/='
		public Keyword getSolidusEqualsSignKeyword_3() { return cSolidusEqualsSignKeyword_3; }
		
		//'%='
		public Keyword getPercentSignEqualsSignKeyword_4() { return cPercentSignEqualsSignKeyword_4; }
		
		//'**='
		public Keyword getAsteriskAsteriskEqualsSignKeyword_5() { return cAsteriskAsteriskEqualsSignKeyword_5; }
		
		//'<' '<' '='
		public Group getGroup_6() { return cGroup_6; }
		
		//'<'
		public Keyword getLessThanSignKeyword_6_0() { return cLessThanSignKeyword_6_0; }
		
		//'<'
		public Keyword getLessThanSignKeyword_6_1() { return cLessThanSignKeyword_6_1; }
		
		//'='
		public Keyword getEqualsSignKeyword_6_2() { return cEqualsSignKeyword_6_2; }
		
		//'>' '>'? '>='
		public Group getGroup_7() { return cGroup_7; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_7_0() { return cGreaterThanSignKeyword_7_0; }
		
		//'>'?
		public Keyword getGreaterThanSignKeyword_7_1() { return cGreaterThanSignKeyword_7_1; }
		
		//'>='
		public Keyword getGreaterThanSignEqualsSignKeyword_7_2() { return cGreaterThanSignEqualsSignKeyword_7_2; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.epic.perl.Perl.Expression");
		private final RuleCall cOrParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Expression:
		//	Or;
		@Override public ParserRule getRule() { return rule; }
		
		//Or
		public RuleCall getOrParserRuleCall() { return cOrParserRuleCall; }
	}
	public class OrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.epic.perl.Perl.Or");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpOpOrParserRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAndParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Or Expression:
		//	And ({Or.left=current} op=OpOr right=And)*
		@Override public ParserRule getRule() { return rule; }
		
		//And ({Or.left=current} op=OpOr right=And)*
		public Group getGroup() { return cGroup; }
		
		//And
		public RuleCall getAndParserRuleCall_0() { return cAndParserRuleCall_0; }
		
		//({Or.left=current} op=OpOr right=And)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Or.left=current}
		public Action getOrLeftAction_1_0() { return cOrLeftAction_1_0; }
		
		//op=OpOr
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//OpOr
		public RuleCall getOpOpOrParserRuleCall_1_1_0() { return cOpOpOrParserRuleCall_1_1_0; }
		
		//right=And
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//And
		public RuleCall getRightAndParserRuleCall_1_2_0() { return cRightAndParserRuleCall_1_2_0; }
	}
	public class OpOrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.epic.perl.Perl.OpOr");
		private final Keyword cVerticalLineVerticalLineKeyword = (Keyword)rule.eContents().get(1);
		
		//OpOr:
		//	'||';
		@Override public ParserRule getRule() { return rule; }
		
		//'||'
		public Keyword getVerticalLineVerticalLineKeyword() { return cVerticalLineVerticalLineKeyword; }
	}
	public class AndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.epic.perl.Perl.And");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cEqualityParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpOpAndParserRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightEqualityParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//And Expression:
		//	Equality ({And.left=current} op=OpAnd right=Equality)*
		@Override public ParserRule getRule() { return rule; }
		
		//Equality ({And.left=current} op=OpAnd right=Equality)*
		public Group getGroup() { return cGroup; }
		
		//Equality
		public RuleCall getEqualityParserRuleCall_0() { return cEqualityParserRuleCall_0; }
		
		//({And.left=current} op=OpAnd right=Equality)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{And.left=current}
		public Action getAndLeftAction_1_0() { return cAndLeftAction_1_0; }
		
		//op=OpAnd
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//OpAnd
		public RuleCall getOpOpAndParserRuleCall_1_1_0() { return cOpOpAndParserRuleCall_1_1_0; }
		
		//right=Equality
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Equality
		public RuleCall getRightEqualityParserRuleCall_1_2_0() { return cRightEqualityParserRuleCall_1_2_0; }
	}
	public class OpAndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.epic.perl.Perl.OpAnd");
		private final Keyword cAmpersandAmpersandKeyword = (Keyword)rule.eContents().get(1);
		
		//OpAnd:
		//	'&&';
		@Override public ParserRule getRule() { return rule; }
		
		//'&&'
		public Keyword getAmpersandAmpersandKeyword() { return cAmpersandAmpersandKeyword; }
	}
	public class EqualityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.epic.perl.Perl.Equality");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cComparisonParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cEqualityLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpOpEqualityParserRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightComparisonParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Equality Expression:
		//	Comparison ({Equality.left=current} op=OpEquality
		//	right=Comparison)*
		@Override public ParserRule getRule() { return rule; }
		
		//Comparison ({Equality.left=current} op=OpEquality right=Comparison)*
		public Group getGroup() { return cGroup; }
		
		//Comparison
		public RuleCall getComparisonParserRuleCall_0() { return cComparisonParserRuleCall_0; }
		
		//({Equality.left=current} op=OpEquality right=Comparison)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Equality.left=current}
		public Action getEqualityLeftAction_1_0() { return cEqualityLeftAction_1_0; }
		
		//op=OpEquality
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//OpEquality
		public RuleCall getOpOpEqualityParserRuleCall_1_1_0() { return cOpOpEqualityParserRuleCall_1_1_0; }
		
		//right=Comparison
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Comparison
		public RuleCall getRightComparisonParserRuleCall_1_2_0() { return cRightComparisonParserRuleCall_1_2_0; }
	}
	public class OpEqualityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.epic.perl.Perl.OpEquality");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cEqualsSignEqualsSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cExclamationMarkEqualsSignKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cEqKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cNeKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		
		//OpEquality:
		//	'==' | '!=' | 'eq' | 'ne';
		@Override public ParserRule getRule() { return rule; }
		
		//'==' | '!=' | 'eq' | 'ne'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'=='
		public Keyword getEqualsSignEqualsSignKeyword_0() { return cEqualsSignEqualsSignKeyword_0; }
		
		//'!='
		public Keyword getExclamationMarkEqualsSignKeyword_1() { return cExclamationMarkEqualsSignKeyword_1; }
		
		//'eq'
		public Keyword getEqKeyword_2() { return cEqKeyword_2; }
		
		//'ne'
		public Keyword getNeKeyword_3() { return cNeKeyword_3; }
	}
	public class ComparisonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.epic.perl.Perl.Comparison");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPlusOrMinusParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cComparisonLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpGreaterThanSignEqualsSignKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpLessThanSignEqualsSignKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Keyword cOpGreaterThanSignKeyword_1_1_0_2 = (Keyword)cOpAlternatives_1_1_0.eContents().get(2);
		private final Keyword cOpLessThanSignKeyword_1_1_0_3 = (Keyword)cOpAlternatives_1_1_0.eContents().get(3);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPlusOrMinusParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Comparison Expression:
		//	PlusOrMinus ({Comparison.left=current} op=(">=" | "<=" | ">" | "<") right=PlusOrMinus)*
		@Override public ParserRule getRule() { return rule; }
		
		//PlusOrMinus ({Comparison.left=current} op=(">=" | "<=" | ">" | "<") right=PlusOrMinus)*
		public Group getGroup() { return cGroup; }
		
		//PlusOrMinus
		public RuleCall getPlusOrMinusParserRuleCall_0() { return cPlusOrMinusParserRuleCall_0; }
		
		//({Comparison.left=current} op=(">=" | "<=" | ">" | "<") right=PlusOrMinus)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Comparison.left=current}
		public Action getComparisonLeftAction_1_0() { return cComparisonLeftAction_1_0; }
		
		//op=(">=" | "<=" | ">" | "<")
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//(">=" | "<=" | ">" | "<")
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }
		
		//">="
		public Keyword getOpGreaterThanSignEqualsSignKeyword_1_1_0_0() { return cOpGreaterThanSignEqualsSignKeyword_1_1_0_0; }
		
		//"<="
		public Keyword getOpLessThanSignEqualsSignKeyword_1_1_0_1() { return cOpLessThanSignEqualsSignKeyword_1_1_0_1; }
		
		//">"
		public Keyword getOpGreaterThanSignKeyword_1_1_0_2() { return cOpGreaterThanSignKeyword_1_1_0_2; }
		
		//"<"
		public Keyword getOpLessThanSignKeyword_1_1_0_3() { return cOpLessThanSignKeyword_1_1_0_3; }
		
		//right=PlusOrMinus
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//PlusOrMinus
		public RuleCall getRightPlusOrMinusParserRuleCall_1_2_0() { return cRightPlusOrMinusParserRuleCall_1_2_0; }
	}
	public class PlusOrMinusElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.epic.perl.Perl.PlusOrMinus");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMulOrDivParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cPlusLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cMinusLeftAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightMulOrDivParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//PlusOrMinus Expression:
		//	MulOrDiv (({Plus.left=current} '+' | {Minus.left=current} '-') right=MulOrDiv)*
		@Override public ParserRule getRule() { return rule; }
		
		//MulOrDiv (({Plus.left=current} '+' | {Minus.left=current} '-') right=MulOrDiv)*
		public Group getGroup() { return cGroup; }
		
		//MulOrDiv
		public RuleCall getMulOrDivParserRuleCall_0() { return cMulOrDivParserRuleCall_0; }
		
		//(({Plus.left=current} '+' | {Minus.left=current} '-') right=MulOrDiv)*
		public Group getGroup_1() { return cGroup_1; }
		
		//({Plus.left=current} '+' | {Minus.left=current} '-')
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//{Plus.left=current} '+'
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{Plus.left=current}
		public Action getPlusLeftAction_1_0_0_0() { return cPlusLeftAction_1_0_0_0; }
		
		//'+'
		public Keyword getPlusSignKeyword_1_0_0_1() { return cPlusSignKeyword_1_0_0_1; }
		
		//{Minus.left=current} '-'
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }
		
		//{Minus.left=current}
		public Action getMinusLeftAction_1_0_1_0() { return cMinusLeftAction_1_0_1_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_1_0_1_1() { return cHyphenMinusKeyword_1_0_1_1; }
		
		//right=MulOrDiv
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//MulOrDiv
		public RuleCall getRightMulOrDivParserRuleCall_1_1_0() { return cRightMulOrDivParserRuleCall_1_1_0; }
	}
	public class MulOrDivElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.epic.perl.Perl.MulOrDiv");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMulOrDivLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpOpMulOrDivParserRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPrimaryParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//MulOrDiv Expression:
		//	Primary ({MulOrDiv.left=current} op=OpMulOrDiv
		//	right=Primary)*
		@Override public ParserRule getRule() { return rule; }
		
		//Primary ({MulOrDiv.left=current} op=OpMulOrDiv right=Primary)*
		public Group getGroup() { return cGroup; }
		
		//Primary
		public RuleCall getPrimaryParserRuleCall_0() { return cPrimaryParserRuleCall_0; }
		
		//({MulOrDiv.left=current} op=OpMulOrDiv right=Primary)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{MulOrDiv.left=current}
		public Action getMulOrDivLeftAction_1_0() { return cMulOrDivLeftAction_1_0; }
		
		//op=OpMulOrDiv
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//OpMulOrDiv
		public RuleCall getOpOpMulOrDivParserRuleCall_1_1_0() { return cOpOpMulOrDivParserRuleCall_1_1_0; }
		
		//right=Primary
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Primary
		public RuleCall getRightPrimaryParserRuleCall_1_2_0() { return cRightPrimaryParserRuleCall_1_2_0; }
	}
	public class OpMulOrDivElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.epic.perl.Perl.OpMulOrDiv");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAsteriskKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cAsteriskAsteriskKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cSolidusKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cPercentSignKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		
		//OpMulOrDiv:
		//	'*' | '**' | '/' | '%';
		@Override public ParserRule getRule() { return rule; }
		
		//'*' | '**' | '/' | '%'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'*'
		public Keyword getAsteriskKeyword_0() { return cAsteriskKeyword_0; }
		
		//'**'
		public Keyword getAsteriskAsteriskKeyword_1() { return cAsteriskAsteriskKeyword_1; }
		
		//'/'
		public Keyword getSolidusKeyword_2() { return cSolidusKeyword_2; }
		
		//'%'
		public Keyword getPercentSignKeyword_3() { return cPercentSignKeyword_3; }
	}
	public class PrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.epic.perl.Perl.Primary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cNotAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cExclamationMarkKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cExpressionPrimaryParserRuleCall_1_2_0 = (RuleCall)cExpressionAssignment_1_2.eContents().get(0);
		private final RuleCall cAtomicParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		////
		////Unary returns Expression:
		////	op=OpUnary {Unary.right=current}
		////;
		////
		////OpUnary:
		////	"!" | "-" | "+";
		//Primary Expression:
		//	'(' Expression ')' | {Not} "!" expression=Primary | Atomic
		@Override public ParserRule getRule() { return rule; }
		
		//'(' Expression ')' | {Not} "!" expression=Primary | Atomic
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'(' Expression ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_0_1() { return cExpressionParserRuleCall_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }
		
		//{Not} "!" expression=Primary
		public Group getGroup_1() { return cGroup_1; }
		
		//{Not}
		public Action getNotAction_1_0() { return cNotAction_1_0; }
		
		//"!"
		public Keyword getExclamationMarkKeyword_1_1() { return cExclamationMarkKeyword_1_1; }
		
		//expression=Primary
		public Assignment getExpressionAssignment_1_2() { return cExpressionAssignment_1_2; }
		
		//Primary
		public RuleCall getExpressionPrimaryParserRuleCall_1_2_0() { return cExpressionPrimaryParserRuleCall_1_2_0; }
		
		//Atomic
		public RuleCall getAtomicParserRuleCall_2() { return cAtomicParserRuleCall_2; }
	}
	public class AtomicElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.epic.perl.Perl.Atomic");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNumberLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNullLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cStringLiteralParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cVariableRefParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//Atomic Expression:
		//	NumberLiteral | NullLiteral | StringLiteral | VariableRef
		@Override public ParserRule getRule() { return rule; }
		
		//NumberLiteral | NullLiteral | StringLiteral | VariableRef
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//NumberLiteral
		public RuleCall getNumberLiteralParserRuleCall_0() { return cNumberLiteralParserRuleCall_0; }
		
		//NullLiteral
		public RuleCall getNullLiteralParserRuleCall_1() { return cNullLiteralParserRuleCall_1; }
		
		//StringLiteral
		public RuleCall getStringLiteralParserRuleCall_2() { return cStringLiteralParserRuleCall_2; }
		
		//VariableRef
		public RuleCall getVariableRefParserRuleCall_3() { return cVariableRefParserRuleCall_3; }
	}
	public class VariableRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.epic.perl.Perl.VariableRef");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//VariableRef:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class NumberLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.epic.perl.Perl.NumberLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNumberLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueNumberParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//NumberLiteral Expression:
		//	{NumberLiteral} value=Number
		@Override public ParserRule getRule() { return rule; }
		
		//{NumberLiteral} value=Number
		public Group getGroup() { return cGroup; }
		
		//{NumberLiteral}
		public Action getNumberLiteralAction_0() { return cNumberLiteralAction_0; }
		
		//value=Number
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//Number
		public RuleCall getValueNumberParserRuleCall_1_0() { return cValueNumberParserRuleCall_1_0; }
	}
	public class NullLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.epic.perl.Perl.NullLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNullLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cUndefKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//NullLiteral Expression:
		//	{NullLiteral} 'undef'
		@Override public ParserRule getRule() { return rule; }
		
		//{NullLiteral} 'undef'
		public Group getGroup() { return cGroup; }
		
		//{NullLiteral}
		public Action getNullLiteralAction_0() { return cNullLiteralAction_0; }
		
		//'undef'
		public Keyword getUndefKeyword_1() { return cUndefKeyword_1; }
	}
	public class StringLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.epic.perl.Perl.StringLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cStringLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//StringLiteral Expression:
		//	{StringLiteral} value=STRING
		@Override public ParserRule getRule() { return rule; }
		
		//{StringLiteral} value=STRING
		public Group getGroup() { return cGroup; }
		
		//{StringLiteral}
		public Action getStringLiteralAction_0() { return cStringLiteralAction_0; }
		
		//value=STRING
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_1_0() { return cValueSTRINGTerminalRuleCall_1_0; }
	}
	public class NumberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.epic.perl.Perl.Number");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cHEXTerminalRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cBINTerminalRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0_2 = (RuleCall)cAlternatives_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		////
		////
		////PExpression returns PExpression:
		////	PAssignment
		////	| PAdditiveExpression 
		////	| PLiteral
		////;
		////
		//////PExpression returns PExpression :
		//////	PAssignment
		//////;
		//////
		//////PAssignment returns PExpression :
		//////	{PAssignment} var=PVar OpSingleAssign value=PAssignment |	
		//////	POrExpression (
		//////		=>({PBinaryOperation.leftOperand=current} feature=OpMultiAssign) rightOperand=PAssignment
		//////	)?;
		//////
		//////OpSingleAssign:
		//////	'='
		//////;
		//////
		//////OpMultiAssign:
		//////	'+=' | '-=' | '*=' | '/=' | '%=' | '**=' |
		//////	'<' '<' '=' | 
		//////	'>' '>'? '>=';
		//////
		//////POrExpression returns PExpression:
		//////	PAndExpression (=>({PBinaryOperation.leftOperand=current} feature=OpOr) rightOperand=PAndExpression)*;
		//////
		//////OpOr:
		//////	'||';
		//////
		//////PAndExpression returns PExpression:
		//////	PEqualityExpression (=>({PBinaryOperation.leftOperand=current} feature=OpAnd) rightOperand=PEqualityExpression)*;
		//////
		//////OpAnd:
		//////	'&&';
		//////
		//////PEqualityExpression returns PExpression:
		//////	PRelationalExpression (=>({PBinaryOperation.leftOperand=current} feature=OpEquality)
		//////	rightOperand=PRelationalExpression)*;
		//////
		//////OpEquality:
		//////	'==' | '!=' | 'eq' | 'ne';
		//////
		//////PRelationalExpression returns PExpression:
		//////	POtherOperatorExpression
		//////	(=>({PBinaryOperation.leftOperand=current} feature=OpCompare) rightOperand=POtherOperatorExpression)*;
		//////
		//////OpCompare:
		//////	'>=' | '<' '=' | '>' | '<' ;
		//////
		//////POtherOperatorExpression returns PExpression:
		//////	PAdditiveExpression (=>({PBinaryOperation.leftOperand=current} feature=OpOther)
		//////	rightOperand=PAdditiveExpression)*;
		//////
		//////OpOther:
		//////	  '>' (=>('>' '>') | '>')
		//////	| '<' (=>('<' '<') | '<' | '=>')
		//////	| '<>'
		//////	| '?:';
		//////
		////
		////PAdditiveExpression returns PExpression:
		////	PMultiplicativeExpression (=>({PBinaryOperation.leftOperand=current} variable=[Variable])
		////	rightOperand=PMultiplicativeExpression)*;
		////
		////OpAdd:
		////	'+' | '-';
		////
		////PMultiplicativeExpression returns PExpression:
		////	PUnaryOperation (=>({PBinaryOperation.leftOperand=current} variable=[Variable]) rightOperand=PUnaryOperation)*;
		////
		////OpMulti:
		////	'*' | '**' | '/' | '%';
		////
		////PUnaryOperation returns PExpression:
		////	{PUnaryOperation} variable=[Variable] operand=PUnaryOperation
		////;
		////
		////OpUnary:
		////	"!" | "-" | "+";
		//////
		//////PPostfixOperation returns PExpression:
		//////	{PPostfixOperation}
		//////	var=PVar =>({PPostfixOperation.operand=current} feature=OpPostfix)?
		//////;
		//////
		//////OpPostfix:
		//////	"++" | "--"
		//////;
		//////
		//////PVar:
		//////	VAR_START ID
		//////;
		//////
		//////PPrimaryExpression returns PExpression:
		//////	PBlockExpression |
		//////	PLiteral |
		//////	PIfExpression |
		//////	PReturnExpression |
		//////	PParenthesizedExpression
		//////;		
		//////
		//////PLiteral returns PExpression:
		//////	PClosure |
		//////	PNumberLiteral |
		//////	PNullLiteral |
		//////	PStringLiteral
		//////;
		//////
		//////PClosure returns PExpression:
		//////	=>({PClosure} 
		//////	'sub' '{') 
		//////		expression=PExpressionInClosure 
		//////	'}'
		//////;
		//////
		//////PExpressionInClosure returns PExpression: 
		//////	{PBlockExpression}
		//////	(expressions+=PExpressionOrVarDeclaration ';'?)*
		//////;
		//////
		//////PParenthesizedExpression returns PExpression:
		//////	'(' PExpression ')'
		//////;
		//////
		//////PIfExpression returns PExpression:
		//////	{PIfExpression}
		//////	'if' '(' if=PExpression ')'
		//////	then=PExpression
		//////	(=>'else' else=PExpression)?;
		//////
		//////PBlockExpression returns PExpression: 
		//////	{PBlockExpression}
		//////	'{'
		//////		(expressions+=PExpressionOrVarDeclaration ';'?)*
		//////	'}';
		//////
		//////PExpressionOrVarDeclaration returns PExpression:
		//////	PVariableDeclaration | PExpression;
		//////
		//////PVariableDeclaration returns PExpression:
		//////	{PVariableDeclaration}
		//////	('my'|'our'|'local') (=>(name=PVar)) ('=' right=PExpression)?;
		//////
		//////PConstructorCall returns PExpression:
		//////	{PConstructorCall}
		//////	'new' constructor=QualifiedName
		//////	(=>explicitConstructorCall?='(' 
		//////		arguments+=PExpression (',' arguments+=PExpression)*
		//////	')')?
		//////;
		//////
		////
		//////
		//////PReturnExpression returns PExpression:
		//////	{PReturnExpression} 'return' (->expression=PExpression)?;
		//////
		////
		////PLiteral returns PExpression:
		////	PNumberLiteral
		////	| PNullLiteral
		////	| PStringLiteral
		//////	| PPackageLiteral
		////;
		////
		////PAssignment returns PExpression:
		////	Variable '=' expression=PExpression;
		////
		//Number hidden():
		//	(HEX | BIN | INT) ('.' INT)?;
		@Override public ParserRule getRule() { return rule; }
		
		//(HEX | BIN | INT) ('.' INT)?
		public Group getGroup() { return cGroup; }
		
		//(HEX | BIN | INT)
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//HEX
		public RuleCall getHEXTerminalRuleCall_0_0() { return cHEXTerminalRuleCall_0_0; }
		
		//BIN
		public RuleCall getBINTerminalRuleCall_0_1() { return cBINTerminalRuleCall_0_1; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_0_2() { return cINTTerminalRuleCall_0_2; }
		
		//('.' INT)?
		public Group getGroup_1() { return cGroup_1; }
		
		//'.'
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_1_1() { return cINTTerminalRuleCall_1_1; }
	}
	
	
	private final PerlModelElements pPerlModel;
	private final AbstractElementElements pAbstractElement;
	private final AssignmentElements pAssignment;
	private final OpSingleAssignElements pOpSingleAssign;
	private final OpMultiAssignElements pOpMultiAssign;
	private final ExpressionElements pExpression;
	private final OrElements pOr;
	private final OpOrElements pOpOr;
	private final AndElements pAnd;
	private final OpAndElements pOpAnd;
	private final EqualityElements pEquality;
	private final OpEqualityElements pOpEquality;
	private final ComparisonElements pComparison;
	private final PlusOrMinusElements pPlusOrMinus;
	private final MulOrDivElements pMulOrDiv;
	private final OpMulOrDivElements pOpMulOrDiv;
	private final PrimaryElements pPrimary;
	private final AtomicElements pAtomic;
	private final VariableRefElements pVariableRef;
	private final NumberLiteralElements pNumberLiteral;
	private final NullLiteralElements pNullLiteral;
	private final StringLiteralElements pStringLiteral;
	private final NumberElements pNumber;
	private final TerminalRule tVAR_START;
	private final TerminalRule tID;
	private final TerminalRule tHEX;
	private final TerminalRule tBIN;
	private final TerminalRule tINT;
	private final TerminalRule tSTRING;
	private final TerminalRule tSL_COMMENT;
	private final TerminalRule tWS;
	
	private final Grammar grammar;

	@Inject
	public PerlGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.pPerlModel = new PerlModelElements();
		this.pAbstractElement = new AbstractElementElements();
		this.pAssignment = new AssignmentElements();
		this.pOpSingleAssign = new OpSingleAssignElements();
		this.pOpMultiAssign = new OpMultiAssignElements();
		this.pExpression = new ExpressionElements();
		this.pOr = new OrElements();
		this.pOpOr = new OpOrElements();
		this.pAnd = new AndElements();
		this.pOpAnd = new OpAndElements();
		this.pEquality = new EqualityElements();
		this.pOpEquality = new OpEqualityElements();
		this.pComparison = new ComparisonElements();
		this.pPlusOrMinus = new PlusOrMinusElements();
		this.pMulOrDiv = new MulOrDivElements();
		this.pOpMulOrDiv = new OpMulOrDivElements();
		this.pPrimary = new PrimaryElements();
		this.pAtomic = new AtomicElements();
		this.pVariableRef = new VariableRefElements();
		this.pNumberLiteral = new NumberLiteralElements();
		this.pNullLiteral = new NullLiteralElements();
		this.pStringLiteral = new StringLiteralElements();
		this.pNumber = new NumberElements();
		this.tVAR_START = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.epic.perl.Perl.VAR_START");
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.epic.perl.Perl.ID");
		this.tHEX = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.epic.perl.Perl.HEX");
		this.tBIN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.epic.perl.Perl.BIN");
		this.tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.epic.perl.Perl.INT");
		this.tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.epic.perl.Perl.STRING");
		this.tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.epic.perl.Perl.SL_COMMENT");
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.epic.perl.Perl.WS");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.epic.perl.Perl".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	//PerlModel:
	//	elements+=AbstractElement*;
	public PerlModelElements getPerlModelAccess() {
		return pPerlModel;
	}
	
	public ParserRule getPerlModelRule() {
		return getPerlModelAccess().getRule();
	}
	
	//AbstractElement:
	//	Assignment | Expression;
	public AbstractElementElements getAbstractElementAccess() {
		return pAbstractElement;
	}
	
	public ParserRule getAbstractElementRule() {
		return getAbstractElementAccess().getRule();
	}
	
	//Assignment:
	//	('my' | 'our' | 'local')? variable=ID op=(OpSingleAssign | OpMultiAssign) expression=Expression;
	public AssignmentElements getAssignmentAccess() {
		return pAssignment;
	}
	
	public ParserRule getAssignmentRule() {
		return getAssignmentAccess().getRule();
	}
	
	//OpSingleAssign:
	//	'=';
	public OpSingleAssignElements getOpSingleAssignAccess() {
		return pOpSingleAssign;
	}
	
	public ParserRule getOpSingleAssignRule() {
		return getOpSingleAssignAccess().getRule();
	}
	
	//OpMultiAssign:
	//	'+=' | '-=' | '*=' | '/=' | '%=' | '**=' |
	//	'<' '<' '=' |
	//	'>' '>'? '>=';
	public OpMultiAssignElements getOpMultiAssignAccess() {
		return pOpMultiAssign;
	}
	
	public ParserRule getOpMultiAssignRule() {
		return getOpMultiAssignAccess().getRule();
	}
	
	//Expression:
	//	Or;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//Or Expression:
	//	And ({Or.left=current} op=OpOr right=And)*
	public OrElements getOrAccess() {
		return pOr;
	}
	
	public ParserRule getOrRule() {
		return getOrAccess().getRule();
	}
	
	//OpOr:
	//	'||';
	public OpOrElements getOpOrAccess() {
		return pOpOr;
	}
	
	public ParserRule getOpOrRule() {
		return getOpOrAccess().getRule();
	}
	
	//And Expression:
	//	Equality ({And.left=current} op=OpAnd right=Equality)*
	public AndElements getAndAccess() {
		return pAnd;
	}
	
	public ParserRule getAndRule() {
		return getAndAccess().getRule();
	}
	
	//OpAnd:
	//	'&&';
	public OpAndElements getOpAndAccess() {
		return pOpAnd;
	}
	
	public ParserRule getOpAndRule() {
		return getOpAndAccess().getRule();
	}
	
	//Equality Expression:
	//	Comparison ({Equality.left=current} op=OpEquality
	//	right=Comparison)*
	public EqualityElements getEqualityAccess() {
		return pEquality;
	}
	
	public ParserRule getEqualityRule() {
		return getEqualityAccess().getRule();
	}
	
	//OpEquality:
	//	'==' | '!=' | 'eq' | 'ne';
	public OpEqualityElements getOpEqualityAccess() {
		return pOpEquality;
	}
	
	public ParserRule getOpEqualityRule() {
		return getOpEqualityAccess().getRule();
	}
	
	//Comparison Expression:
	//	PlusOrMinus ({Comparison.left=current} op=(">=" | "<=" | ">" | "<") right=PlusOrMinus)*
	public ComparisonElements getComparisonAccess() {
		return pComparison;
	}
	
	public ParserRule getComparisonRule() {
		return getComparisonAccess().getRule();
	}
	
	//PlusOrMinus Expression:
	//	MulOrDiv (({Plus.left=current} '+' | {Minus.left=current} '-') right=MulOrDiv)*
	public PlusOrMinusElements getPlusOrMinusAccess() {
		return pPlusOrMinus;
	}
	
	public ParserRule getPlusOrMinusRule() {
		return getPlusOrMinusAccess().getRule();
	}
	
	//MulOrDiv Expression:
	//	Primary ({MulOrDiv.left=current} op=OpMulOrDiv
	//	right=Primary)*
	public MulOrDivElements getMulOrDivAccess() {
		return pMulOrDiv;
	}
	
	public ParserRule getMulOrDivRule() {
		return getMulOrDivAccess().getRule();
	}
	
	//OpMulOrDiv:
	//	'*' | '**' | '/' | '%';
	public OpMulOrDivElements getOpMulOrDivAccess() {
		return pOpMulOrDiv;
	}
	
	public ParserRule getOpMulOrDivRule() {
		return getOpMulOrDivAccess().getRule();
	}
	
	////
	////Unary returns Expression:
	////	op=OpUnary {Unary.right=current}
	////;
	////
	////OpUnary:
	////	"!" | "-" | "+";
	//Primary Expression:
	//	'(' Expression ')' | {Not} "!" expression=Primary | Atomic
	public PrimaryElements getPrimaryAccess() {
		return pPrimary;
	}
	
	public ParserRule getPrimaryRule() {
		return getPrimaryAccess().getRule();
	}
	
	//Atomic Expression:
	//	NumberLiteral | NullLiteral | StringLiteral | VariableRef
	public AtomicElements getAtomicAccess() {
		return pAtomic;
	}
	
	public ParserRule getAtomicRule() {
		return getAtomicAccess().getRule();
	}
	
	//VariableRef:
	//	name=ID;
	public VariableRefElements getVariableRefAccess() {
		return pVariableRef;
	}
	
	public ParserRule getVariableRefRule() {
		return getVariableRefAccess().getRule();
	}
	
	//NumberLiteral Expression:
	//	{NumberLiteral} value=Number
	public NumberLiteralElements getNumberLiteralAccess() {
		return pNumberLiteral;
	}
	
	public ParserRule getNumberLiteralRule() {
		return getNumberLiteralAccess().getRule();
	}
	
	//NullLiteral Expression:
	//	{NullLiteral} 'undef'
	public NullLiteralElements getNullLiteralAccess() {
		return pNullLiteral;
	}
	
	public ParserRule getNullLiteralRule() {
		return getNullLiteralAccess().getRule();
	}
	
	//StringLiteral Expression:
	//	{StringLiteral} value=STRING
	public StringLiteralElements getStringLiteralAccess() {
		return pStringLiteral;
	}
	
	public ParserRule getStringLiteralRule() {
		return getStringLiteralAccess().getRule();
	}
	
	////
	////
	////PExpression returns PExpression:
	////	PAssignment
	////	| PAdditiveExpression 
	////	| PLiteral
	////;
	////
	//////PExpression returns PExpression :
	//////	PAssignment
	//////;
	//////
	//////PAssignment returns PExpression :
	//////	{PAssignment} var=PVar OpSingleAssign value=PAssignment |	
	//////	POrExpression (
	//////		=>({PBinaryOperation.leftOperand=current} feature=OpMultiAssign) rightOperand=PAssignment
	//////	)?;
	//////
	//////OpSingleAssign:
	//////	'='
	//////;
	//////
	//////OpMultiAssign:
	//////	'+=' | '-=' | '*=' | '/=' | '%=' | '**=' |
	//////	'<' '<' '=' | 
	//////	'>' '>'? '>=';
	//////
	//////POrExpression returns PExpression:
	//////	PAndExpression (=>({PBinaryOperation.leftOperand=current} feature=OpOr) rightOperand=PAndExpression)*;
	//////
	//////OpOr:
	//////	'||';
	//////
	//////PAndExpression returns PExpression:
	//////	PEqualityExpression (=>({PBinaryOperation.leftOperand=current} feature=OpAnd) rightOperand=PEqualityExpression)*;
	//////
	//////OpAnd:
	//////	'&&';
	//////
	//////PEqualityExpression returns PExpression:
	//////	PRelationalExpression (=>({PBinaryOperation.leftOperand=current} feature=OpEquality)
	//////	rightOperand=PRelationalExpression)*;
	//////
	//////OpEquality:
	//////	'==' | '!=' | 'eq' | 'ne';
	//////
	//////PRelationalExpression returns PExpression:
	//////	POtherOperatorExpression
	//////	(=>({PBinaryOperation.leftOperand=current} feature=OpCompare) rightOperand=POtherOperatorExpression)*;
	//////
	//////OpCompare:
	//////	'>=' | '<' '=' | '>' | '<' ;
	//////
	//////POtherOperatorExpression returns PExpression:
	//////	PAdditiveExpression (=>({PBinaryOperation.leftOperand=current} feature=OpOther)
	//////	rightOperand=PAdditiveExpression)*;
	//////
	//////OpOther:
	//////	  '>' (=>('>' '>') | '>')
	//////	| '<' (=>('<' '<') | '<' | '=>')
	//////	| '<>'
	//////	| '?:';
	//////
	////
	////PAdditiveExpression returns PExpression:
	////	PMultiplicativeExpression (=>({PBinaryOperation.leftOperand=current} variable=[Variable])
	////	rightOperand=PMultiplicativeExpression)*;
	////
	////OpAdd:
	////	'+' | '-';
	////
	////PMultiplicativeExpression returns PExpression:
	////	PUnaryOperation (=>({PBinaryOperation.leftOperand=current} variable=[Variable]) rightOperand=PUnaryOperation)*;
	////
	////OpMulti:
	////	'*' | '**' | '/' | '%';
	////
	////PUnaryOperation returns PExpression:
	////	{PUnaryOperation} variable=[Variable] operand=PUnaryOperation
	////;
	////
	////OpUnary:
	////	"!" | "-" | "+";
	//////
	//////PPostfixOperation returns PExpression:
	//////	{PPostfixOperation}
	//////	var=PVar =>({PPostfixOperation.operand=current} feature=OpPostfix)?
	//////;
	//////
	//////OpPostfix:
	//////	"++" | "--"
	//////;
	//////
	//////PVar:
	//////	VAR_START ID
	//////;
	//////
	//////PPrimaryExpression returns PExpression:
	//////	PBlockExpression |
	//////	PLiteral |
	//////	PIfExpression |
	//////	PReturnExpression |
	//////	PParenthesizedExpression
	//////;		
	//////
	//////PLiteral returns PExpression:
	//////	PClosure |
	//////	PNumberLiteral |
	//////	PNullLiteral |
	//////	PStringLiteral
	//////;
	//////
	//////PClosure returns PExpression:
	//////	=>({PClosure} 
	//////	'sub' '{') 
	//////		expression=PExpressionInClosure 
	//////	'}'
	//////;
	//////
	//////PExpressionInClosure returns PExpression: 
	//////	{PBlockExpression}
	//////	(expressions+=PExpressionOrVarDeclaration ';'?)*
	//////;
	//////
	//////PParenthesizedExpression returns PExpression:
	//////	'(' PExpression ')'
	//////;
	//////
	//////PIfExpression returns PExpression:
	//////	{PIfExpression}
	//////	'if' '(' if=PExpression ')'
	//////	then=PExpression
	//////	(=>'else' else=PExpression)?;
	//////
	//////PBlockExpression returns PExpression: 
	//////	{PBlockExpression}
	//////	'{'
	//////		(expressions+=PExpressionOrVarDeclaration ';'?)*
	//////	'}';
	//////
	//////PExpressionOrVarDeclaration returns PExpression:
	//////	PVariableDeclaration | PExpression;
	//////
	//////PVariableDeclaration returns PExpression:
	//////	{PVariableDeclaration}
	//////	('my'|'our'|'local') (=>(name=PVar)) ('=' right=PExpression)?;
	//////
	//////PConstructorCall returns PExpression:
	//////	{PConstructorCall}
	//////	'new' constructor=QualifiedName
	//////	(=>explicitConstructorCall?='(' 
	//////		arguments+=PExpression (',' arguments+=PExpression)*
	//////	')')?
	//////;
	//////
	////
	//////
	//////PReturnExpression returns PExpression:
	//////	{PReturnExpression} 'return' (->expression=PExpression)?;
	//////
	////
	////PLiteral returns PExpression:
	////	PNumberLiteral
	////	| PNullLiteral
	////	| PStringLiteral
	//////	| PPackageLiteral
	////;
	////
	////PAssignment returns PExpression:
	////	Variable '=' expression=PExpression;
	////
	//Number hidden():
	//	(HEX | BIN | INT) ('.' INT)?;
	public NumberElements getNumberAccess() {
		return pNumber;
	}
	
	public ParserRule getNumberRule() {
		return getNumberAccess().getRule();
	}
	
	//terminal fragment VAR_START:
	//	('@' | '$' | '%') ('@' | '$' | '%' | '*' | '#')*;
	public TerminalRule getVAR_STARTRule() {
		return tVAR_START;
	}
	
	//terminal ID:
	//	VAR_START ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return tID;
	}
	
	//terminal HEX:
	//	("0x" | "0X") ('0'..'9' | 'a'..'f' | 'A'..'F' | '_')+;
	public TerminalRule getHEXRule() {
		return tHEX;
	}
	
	//terminal BIN:
	//	"0b" ('0'..'1' | '_')+;
	public TerminalRule getBINRule() {
		return tBIN;
	}
	
	//terminal INT:
	//	'0'..'9' ('0'..'9' | '_')*;
	public TerminalRule getINTRule() {
		return tINT;
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return tSTRING;
	}
	
	//terminal SL_COMMENT:
	//	'#' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return tSL_COMMENT;
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return tWS;
	}
}
